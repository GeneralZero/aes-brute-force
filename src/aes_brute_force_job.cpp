#include "aes-brute_force_job.h"
#include "aes_ni_botan.h"
#include <bitset>

std::string aes_brute_force_job::toBinary(std::vector<uint8_t> in){
    std::string ret;

    for(unsigned int i = 0; i < in.size(); i++){
        uint8_t n = in[i];
        while(n!=0){
            if(n%2==0){
                ret = "0" + ret;
            }
            else{
                ret = "1" + ret;
            }
            n/=2;
        }
    }

    return ret;
}

void aes_brute_force_job::recursive_keys(std::string bit_key_mask, unsigned int index, std::string data, std::vector<uint8_t> init_key){
    if(bit_key_mask.size() == data.size()){
        std::vector<uint8_t> new_mask;
        //Convert binstring to uint_8 vector
        for (unsigned int i = 0; i < data.size(); i+= 8)
        {
            //Convert substring to uint_8
            uint8_t byte = static_cast<uint8_t>(std::stoi(data.substr(i, i+8), nullptr, 2));

            //Push new mask combinded with the Inital Key
            new_mask.push_back(byte | init_key[i/8]);
        }
        
        test_keys.push_back(new_mask);
    }   
    else{
        if(bit_key_mask[index] == '1'){
            recursive_keys(bit_key_mask, index + 1, data + "0", init_key);
            recursive_keys(bit_key_mask, index + 1, data + "1", init_key);
        }
        else{
            recursive_keys(bit_key_mask, index + 1, data + "0", init_key);
        }
    }
}


uint64_t aes_brute_force_job::search_continuous(uint8_t byte_min, uint8_t byte_max){
    std::vector<uint8_t> test_cipher;
    std::vector<uint8_t> test_key;

    //Set All Values of the inital key to the byte_min where the mask is approprate
    for (unsigned int byte_index = 0; byte_index < test_key.size(); byte_index++){
        if(key_mask[byte_index] != 0x00){
            test_key[byte_index] = byte_min & key_mask[byte_index];
        }
        else{
            test_key[byte_index] = key_input[byte_index];
        }
    }

    //KeyMask to binary
    std::string bit_key_mask = toBinary(key_mask);

    //Recursive Generate possoble key modifyers that can be generated by the key mask
    recursive_keys(bit_key_mask, 0, "", test_key);

    //Switch statement for Keysizes
    switch (test_key.size()){
        case 16:
            //128 bit key
            uint32_t* test_encryption_keys = new uint32_t[44]();
            uint32_t* test_decryption_keys = new uint32_t[44]();

            for (loop_cnt = 0; loop_cnt < test_keys.size(); loop_cnt++){
                //Get Key Decryption Keys
                aesni_128_key_schedule(test_keys[loop_cnt].data(), &test_encryption_keys, &test_decryption_keys);

                //Get Key Encryption Keys
                aesni_128_encrypt_n(plain.data(), test_cipher.data(), 1, &test_encryption_keys);

                //Test if Ciphertexts are the same
                if(test_cipher == cipher){
                    copy(test_keys[loop_cnt].begin(), test_keys[loop_cnt].end(), back_inserter(correct_key)); 
                    key_found = true;
                    done = true;
                    break;
                }
            }

            delete test_encryption_keys;
            delete test_decryption_keys;

            break;
        case 24:
            //192 bit key
            uint32_t* test_encryption_keys = new uint32_t[52]();
            uint32_t* test_decryption_keys = new uint32_t[52]();

            for (loop_cnt = 0; loop_cnt < test_keys.size(); loop_cnt++){
                //Get Key Decryption Keys
                aesni_192_key_schedule(test_keys[loop_cnt].data(), &test_encryption_keys, &test_decryption_keys);

                //Get Key Encryption Keys
                aesni_192_encrypt_n(plain.data(), test_cipher.data(), 1, &test_encryption_keys);

                //Test if Ciphertexts are the same
                if(test_cipher == cipher){
                    copy(test_keys[loop_cnt].begin(), test_keys[loop_cnt].end(), back_inserter(correct_key)); 
                    key_found = true;
                    done = true;
                    break;
                }
            }

            delete test_encryption_keys;
            delete test_decryption_keys;

            break;
        case 32:
            //256 bit key
            uint32_t* test_encryption_keys = new uint32_t[60]();
            uint32_t* test_decryption_keys = new uint32_t[60]();

            for (loop_cnt = 0; loop_cnt < test_keys.size(); loop_cnt++){
                //Get Key Decryption Keys
                aesni_256_key_schedule(test_keys[loop_cnt].data(), &test_encryption_keys, &test_decryption_keys);

                //Get Key Encryption Keys
                aesni_256_encrypt_n(plain.data(), test_cipher.data(), 1, &test_encryption_keys);

                //Test if Ciphertexts are the same
                if(test_cipher == cipher){
                    copy(test_keys[loop_cnt].begin(), test_keys[loop_cnt].end(), back_inserter(correct_key)); 
                    key_found = true;
                    done = true;
                    break;
                }
            }

            delete test_encryption_keys;
            delete test_decryption_keys;
            break;

        default:
            //Error Invalid Keysize
            break;
    }

    done = true;
    
    return loop_cnt;
}


uint64_t aes_brute_force_job::search(uint8_t byte_min, uint8_t* character_lookup_table){
    std::vector<uint8_t> test_cipher;
    std::vector<uint8_t> test_key;
    std::vector<std::vector<uint8_t>> test_keys;
    uint64_t loop_cnt;

    //Set All Values of the inital key to the byte_min where the mask is approprate
    for (unsigned int byte_index = 0; byte_index < test_key.size(); byte_index++){
        if(key_mask[byte_index] != 0x00){
            test_key[byte_index] = byte_min & key_mask[byte_index];
        }
        else{
            test_key[byte_index] = key_input[byte_index];
        }
    }

    //KeyMask to binary
    std::string bit_key_mask = toBinary(key_mask);

    //Recursive Generate possoble key modifyers that can be generated by the key mask
    recursive_keys(bit_key_mask, 0, "", test_key);

    //Switch statement for Keysizes
    switch (test_key.size()){
        case 16:
            //128 bit key
            uint32_t* test_encryption_keys = new uint32_t[44]();
            uint32_t* test_decryption_keys = new uint32_t[44]();

            for (loop_cnt = 0; loop_cnt < test_keys.size(); loop_cnt++){
                //Get Key Decryption Keys
                aesni_128_key_schedule(test_keys[loop_cnt].data(), &test_encryption_keys, &test_decryption_keys);

                //Get Key Encryption Keys
                aesni_128_encrypt_n(plain.data(), test_cipher.data(), 1, &test_encryption_keys);

                //Test if Ciphertexts are the same
                if(test_cipher == cipher){
                    copy(test_keys[loop_cnt].begin(), test_keys[loop_cnt].end(), back_inserter(correct_key)); 
                    key_found = true;
                    done = true;
                    break;
                }
            }

            delete test_encryption_keys;
            delete test_decryption_keys;

            break;
        case 24:
            //192 bit key
            uint32_t* test_encryption_keys = new uint32_t[52]();
            uint32_t* test_decryption_keys = new uint32_t[52]();

            for (loop_cnt = 0; loop_cnt < test_keys.size(); loop_cnt++){
                //Get Key Decryption Keys
                aesni_192_key_schedule(test_keys[loop_cnt].data(), &test_encryption_keys, &test_decryption_keys);

                //Get Key Encryption Keys
                aesni_192_encrypt_n(plain.data(), test_cipher.data(), 1, &test_encryption_keys);

                //Test if Ciphertexts are the same
                if(test_cipher == cipher){
                    copy(test_keys[loop_cnt].begin(), test_keys[loop_cnt].end(), back_inserter(correct_key)); 
                    key_found = true;
                    done = true;
                    break;
                }
            }

            delete test_encryption_keys;
            delete test_decryption_keys;
            
            break;
        case 32:
            //256 bit key
            uint32_t* test_encryption_keys = new uint32_t[60]();
            uint32_t* test_decryption_keys = new uint32_t[60]();

            for (loop_cnt = 0; loop_cnt < test_keys.size(); loop_cnt++){
                //Get Key Decryption Keys
                aesni_256_key_schedule(test_keys[loop_cnt].data(), &test_encryption_keys, &test_decryption_keys);

                //Get Key Encryption Keys
                aesni_256_encrypt_n(plain.data(), test_cipher.data(), 1, &test_encryption_keys);

                //Test if Ciphertexts are the same
                if(test_cipher == cipher){
                    copy(test_keys[loop_cnt].begin(), test_keys[loop_cnt].end(), back_inserter(correct_key)); 
                    key_found = true;
                    done = true;
                    break;
                }
            }

            delete test_encryption_keys;
            delete test_decryption_keys;
            
            break;

        default:
            //Error Invalid Keysize
            break;
    }

    done = true;
    
    return loop_cnt;
}